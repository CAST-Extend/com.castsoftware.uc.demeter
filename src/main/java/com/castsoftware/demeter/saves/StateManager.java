/*
 * Copyright (C) 2020  Hugo JOBY
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 3 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License v3 for more details.
 *
 * You should have received a copy of the GNU Lesser General Public v3
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 *
 */

package com.castsoftware.demeter.saves;

import com.castsoftware.demeter.config.Configuration;
import com.castsoftware.demeter.database.Neo4jAL;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jBadRequestException;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jNoResult;
import com.castsoftware.demeter.exceptions.neo4j.Neo4jQueryException;
import com.castsoftware.demeter.models.demeter.OperationNode;
import com.castsoftware.demeter.models.demeter.SaveNode;
import com.castsoftware.demeter.models.imaging.Level5Node;
import org.neo4j.graphdb.*;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.zip.GZIPOutputStream;

/** Save the modifications made by the user in Demeter */
public class StateManager {

  // State manager
  private static final String DEFAULT_ENCODING = "UTF-8";
  private static final String PARAGRAPH_DELIMITER = "\n";
  private static final String COLUMN_DELIMITER = ";";
  private static final String OBJ_NAME_DELIMITER = "//";
  private static final String LEVEL_IDENTIFIER = "LEVEL5";
  private static final String MODULE_IDENTIFIER = "MODULE";

  // Static Imaging properties
  private static final String AGGREGATES_REL = Configuration.get("imaging.node.level_nodes.links");
  private static final String IMAGING_OBJECT_LABEL = Configuration.get("imaging.node.object.label");
  private static final String IMAGING_OBJECT_FULL_NAME =
      Configuration.get("imaging.node.object.fullName");
  private static final String GENERATED_LEVEL_PREFIX =
      Configuration.get("demeter.prefix.generated_level_prefix");

  /**
   * Save the demeter modifications to a zip file.
   *
   * @param gout GZIP output stream
   * @param neo4jAL Neo4j Access Layer
   * @param applicationContext Name of the application concerned by this change
   * @throws Neo4jBadRequestException
   * @throws Neo4jNoResult
   * @throws IOException
   */
  private static void saveDemeterLevel5Map(
      GZIPOutputStream gout, Neo4jAL neo4jAL, String applicationContext)
      throws Neo4jNoResult, IOException, Neo4jQueryException {
    Label objectLabel = Label.label(IMAGING_OBJECT_LABEL);
    RelationshipType aggregates = RelationshipType.withName(AGGREGATES_REL);

    // Get all the demeter
    Map<String, String[]> mapLevelFullName = new HashMap<>();

    for (Level5Node level : Level5Node.getAllNodesByApplication(neo4jAL, applicationContext)) {
      String fullName = level.getFullName();

      // If the full name match, the level was generated by Demeter
      if (fullName.matches("(.*)##" + GENERATED_LEVEL_PREFIX + "(.*)")) {
        // Keep level to reassign nodes later
        // Add Name
        Node n = level.getNode();
        String starter = LEVEL_IDENTIFIER + COLUMN_DELIMITER + level.getName() + COLUMN_DELIMITER;
        gout.write(starter.getBytes(DEFAULT_ENCODING));

        // Get connected nodes
        String fullNameEntry;
        for (Iterator<Relationship> relIt =
                n.getRelationships(Direction.OUTGOING, aggregates).iterator();
            relIt.hasNext(); ) {
          Node obj = relIt.next().getEndNode();
          if (obj.hasLabel(objectLabel)) {
            fullNameEntry = (String) obj.getProperty(IMAGING_OBJECT_FULL_NAME) + COLUMN_DELIMITER;
            gout.write(fullNameEntry.getBytes(DEFAULT_ENCODING));
          }
        }

        gout.flush();
      }
    }
  }

  /**
   * Save demeter level to the database
   *
   * @param neo4jAL Neo4j Access Layer
   * @param applicationContext Name of the application concerned by the save
   * @param saveName Name of the save
   * @throws Neo4jQueryException
   * @throws Neo4jNoResult
   */
  public static void saveDemeterLevel5(Neo4jAL neo4jAL, String applicationContext, String saveName)
      throws Neo4jQueryException, Neo4jNoResult {
    Label objectLabel = Label.label(IMAGING_OBJECT_LABEL);
    RelationshipType toSaveRel = RelationshipType.withName(OperationNode.getRelationToSaveNode());
    RelationshipType aggregates = RelationshipType.withName(AGGREGATES_REL);

    // Get all the demeter
    Map<String, String[]> mapLevelFullName = new HashMap<>();

    // Create Save node in the database
    Date date = Calendar.getInstance().getTime();
    DateFormat dateFormat = new SimpleDateFormat("yyyy-mm-dd hh:mm:ss");
    String strDate = dateFormat.format(date);

    SaveNode svn = new SaveNode(neo4jAL, saveName, applicationContext, strDate);
    Node saveNode = svn.createNode();

    for (Level5Node level : Level5Node.getAllNodesByApplication(neo4jAL, applicationContext)) {
      String fullName = level.getFullName();

      // If the full name match, the level was generated by Demeter
      if (fullName.matches("(.*)##" + GENERATED_LEVEL_PREFIX + "(.*)")) {

        Node n = level.getNode();

        // Get connected nodes
        List<String> fullNameList = new ArrayList<>();
        for (Iterator<Relationship> relIt =
                n.getRelationships(Direction.OUTGOING, aggregates).iterator();
            relIt.hasNext(); ) {
          Node obj = relIt.next().getEndNode();
          if (obj.hasLabel(objectLabel) && obj.hasProperty(IMAGING_OBJECT_FULL_NAME)) {
            fullNameList.add((String) obj.getProperty(IMAGING_OBJECT_FULL_NAME));
          }
        }

        // Create operation node
        OperationNode opN = new OperationNode(neo4jAL, level.getName(), fullNameList);
        Node opnode = opN.createNode();

        // Link the operation node to the Save node
        opnode.createRelationshipTo(saveNode, toSaveRel);
      }
    }
  }

  /**
   * Save the current modifications made on the application
   *
   * @param saveFile File used to save the data
   * @param applicationName Name of the application
   */
  public static void saveStateToFile(Neo4jAL neo4jAL, File saveFile, String applicationName)
      throws IOException, Neo4jNoResult, Neo4jQueryException {
    try (FileOutputStream fo = new FileOutputStream(saveFile)) {

      try (GZIPOutputStream gzip = new GZIPOutputStream(fo)) {
        // Get the levels to save
        saveDemeterLevel5Map(gzip, neo4jAL, applicationName);
      }

      // Get the modules to save

      // Save to File
      fo.flush();
    }
  }
}
